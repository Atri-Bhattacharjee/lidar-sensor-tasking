#!/usr/bin/env python3
"""
Debug script to inspect the Labeled Multi-Bernoulli (LMB) filter state.

This script will help diagnose why the detection rate is 0.000 by showing:
1. Ground truth objects at each timestep
2. Measurements generated by the perception layer
3. Tracks created and maintained by the estimation layer
4. Track existence probabilities and state estimates
5. Extraction thresholds and final extracted state
"""

import sys
import os
import numpy as np
import pickle
from typing import Dict, List, Any

# Add the simulation directory to the path
sys.path.append(os.path.join(os.path.dirname(__file__), 'simulation'))

import config
from environment.perception_layer import PerceptionLayer
from environment.estimation_layer import EstimationLayer
from environment.constellation_env import ConstellationEnv
from utils.ospa import calculate_ospa

def debug_lmb_filter():
    """Debug the LMB filter step by step."""
    
    print("="*80)
    print("LMB FILTER DEBUG SCRIPT")
    print("="*80)
    
    # Initialize environment
    print("Initializing environment...")
    env = ConstellationEnv()
    
    # Reset environment
    print("Resetting environment...")
    observation = env.reset()
    
    # Debug for first few timesteps
    num_debug_steps = 5
    
    for timestep in range(num_debug_steps):
        print(f"\n{'='*60}")
        print(f"TIMESTEP {timestep + 1}")
        print(f"{'='*60}")
        
        # Get ground truth for this timestep
        ground_truth_at_t = env.ground_truth.get(timestep, [])
        print(f"Ground Truth Objects: {len(ground_truth_at_t)}")
        
        if ground_truth_at_t:
            print("Ground Truth Details:")
            for i, obj in enumerate(ground_truth_at_t[:3]):  # Show first 3 objects
                pos = obj.get('position', [0, 0, 0])
                vel = obj.get('velocity', [0, 0, 0])
                print(f"  Object {i}: pos={pos[:3]}, vel={vel[:3]}")
        
        # Generate random action for debugging
        action = np.random.uniform(-0.5, 0.5, (config.NUM_SATELLITES, 2))
        
        # Step the environment
        next_observation, reward, done, info = env.step(action)
        
        # Debug measurements
        print(f"\nMeasurements Generated: {info['num_measurements']}")
        
        # Debug estimation layer state
        estimation_layer = env.estimation_layer
        tracks = estimation_layer.tracks
        print(f"Total Tracks in Filter: {len(tracks)}")
        print(f"Extracted Tracks: {info['num_extracted']}")
        
        # Debug track details
        if tracks:
            print("\nTrack Details:")
            for i, track in enumerate(tracks[:5]):  # Show first 5 tracks
                print(f"  Track {i} (Label {track.label}):")
                print(f"    Existence Probability: {track.existence_probability:.4f}")
                print(f"    Number of GMM Components: {len(track.gmm)}")
                
                if track.gmm:
                    # Show first component details
                    comp = track.gmm[0]
                    mean = comp.mean.flatten()
                    weight = comp.weight
                    print(f"    First Component:")
                    print(f"      Weight: {weight:.4f}")
                    print(f"      Position: [{mean[0]:.1f}, {mean[1]:.1f}, {mean[2]:.1f}]")
                    print(f"      Velocity: [{mean[3]:.1f}, {mean[4]:.1f}, {mean[5]:.1f}]")
                    
                    # Show covariance diagonal
                    cov_diag = np.diag(comp.covariance)
                    print(f"      Position Uncertainty: [{cov_diag[0]:.1f}, {cov_diag[1]:.1f}, {cov_diag[2]:.1f}]")
                    print(f"      Velocity Uncertainty: [{cov_diag[3]:.1f}, {cov_diag[4]:.1f}, {cov_diag[5]:.1f}]")
        
        # Debug extraction process
        print(f"\nExtraction Threshold: {config.EXISTENCE_THRESHOLD_EXTRACTION}")
        high_confidence_tracks = [t for t in tracks if t.existence_probability > config.EXISTENCE_THRESHOLD_EXTRACTION]
        print(f"Tracks above extraction threshold: {len(high_confidence_tracks)}")
        
        if high_confidence_tracks:
            print("High Confidence Track Details:")
            for i, track in enumerate(high_confidence_tracks[:3]):
                print(f"  Track {i}: existence={track.existence_probability:.4f}")
        
        # Debug OSPA and detection rate
        print(f"\nPerformance Metrics:")
        print(f"  OSPA Distance: {info['ospa_distance']:.2f}")
        print(f"  Detection Rate: {info['detection_rate']:.4f}")
        
        # Debug measurement association
        if hasattr(estimation_layer, 'unassociated_measurements'):
            print(f"  Unassociated Measurements: {len(estimation_layer.unassociated_measurements)}")
        
        # Check if we should stop early
        if done:
            print("\nEpisode ended early!")
            break
    
    # Final summary
    print(f"\n{'='*80}")
    print("DEBUG SUMMARY")
    print(f"{'='*80}")
    print(f"Total timesteps debugged: {num_debug_steps}")
    print(f"Final number of tracks: {len(env.estimation_layer.tracks)}")
    print(f"Final extracted tracks: {info['num_extracted']}")
    print(f"Final detection rate: {info['detection_rate']:.4f}")
    print(f"Final OSPA: {info['ospa_distance']:.2f}")

def debug_measurement_generation():
    """Debug the measurement generation process specifically."""
    
    print("\n" + "="*80)
    print("MEASUREMENT GENERATION DEBUG")
    print("="*80)
    
    # Initialize perception layer
    perception_layer = PerceptionLayer()
    
    # Create sample ground truth
    sample_ground_truth = [
        {
            'id': 'test_obj_1',
            'position': np.array([7000000.0, 100000.0, 50000.0]),  # Typical LEO position
            'velocity': np.array([-7000.0, 0.0, 0.0]),  # Typical orbital velocity
            'diameter': 1.0,
            'mass': 100.0
        }
    ]
    
    # Create sample action (point towards the object)
    action = np.zeros((config.NUM_SATELLITES, 2))
    action[0] = [0.1, 0.05]  # Small azimuth/elevation offsets
    
    print(f"Sample Ground Truth: {len(sample_ground_truth)} objects")
    print(f"Sample Action Shape: {action.shape}")
    
    # Generate measurements
    measurements = perception_layer.generate_measurements(sample_ground_truth, action)
    
    print(f"Generated Measurements: {len(measurements)}")
    
    if measurements:
        print("\nMeasurement Details:")
        for i, meas in enumerate(measurements[:3]):  # Show first 3 measurements
            print(f"  Measurement {i}:")
            print(f"    Range: {meas.get('range', 'N/A'):.1f} m")
            print(f"    Azimuth: {meas.get('azimuth', 'N/A'):.2f} deg")
            print(f"    Elevation: {meas.get('elevation', 'N/A'):.2f} deg")
            print(f"    Range Rate: {meas.get('range_rate', 'N/A'):.1f} m/s")
            print(f"    Is Clutter: {meas.get('is_clutter', False)}")
            print(f"    Satellite ID: {meas.get('satellite_id', 'N/A')}")

def debug_track_creation():
    """Debug the track creation process."""
    
    print("\n" + "="*80)
    print("TRACK CREATION DEBUG")
    print("="*80)
    
    # Initialize estimation layer
    estimation_layer = EstimationLayer()
    
    # Create sample measurement
    sample_measurement = {
        'range': 5000.0,  # 5km range
        'azimuth': 10.0,  # 10 degrees
        'elevation': 5.0,  # 5 degrees
        'range_rate': 100.0,  # 100 m/s
        'satellite_id': 0
    }
    
    print(f"Sample Measurement: {sample_measurement}")
    
    # Test measurement to GMM conversion
    gmm_components = estimation_layer._measurement_to_gmm(sample_measurement)
    
    print(f"GMM Components Created: {len(gmm_components)}")
    
    if gmm_components:
        comp = gmm_components[0]
        mean = comp.mean.flatten()
        print(f"Component Details:")
        print(f"  Weight: {comp.weight:.4f}")
        print(f"  Position: [{mean[0]:.1f}, {mean[1]:.1f}, {mean[2]:.1f}]")
        print(f"  Velocity: [{mean[3]:.1f}, {mean[4]:.1f}, {mean[5]:.1f}]")
        
        # Show covariance
        cov_diag = np.diag(comp.covariance)
        print(f"  Position Uncertainty: [{cov_diag[0]:.1f}, {cov_diag[1]:.1f}, {cov_diag[2]:.1f}]")
        print(f"  Velocity Uncertainty: [{cov_diag[3]:.1f}, {cov_diag[4]:.1f}, {cov_diag[5]:.1f}]")

def debug_extraction_process():
    """Debug the track extraction process."""
    
    print("\n" + "="*80)
    print("TRACK EXTRACTION DEBUG")
    print("="*80)
    
    # Initialize estimation layer
    estimation_layer = EstimationLayer()
    
    # Create sample tracks with different existence probabilities
    from environment.estimation_layer import Track, GaussianComponent
    
    # Create a high-confidence track
    high_conf_mean = np.array([7000000.0, 100000.0, 50000.0, -7000.0, 0.0, 0.0]).reshape(6, 1)
    high_conf_cov = np.eye(6) * 1000.0  # Low uncertainty
    high_conf_comp = GaussianComponent(1.0, high_conf_mean, high_conf_cov)
    high_conf_track = Track(1, 0.8, [high_conf_comp])  # High existence probability
    
    # Create a low-confidence track
    low_conf_mean = np.array([7000000.0, 200000.0, 100000.0, -7000.0, 0.0, 0.0]).reshape(6, 1)
    low_conf_cov = np.eye(6) * 10000.0  # High uncertainty
    low_conf_comp = GaussianComponent(1.0, low_conf_mean, low_conf_cov)
    low_conf_track = Track(2, 0.1, [low_conf_comp])  # Low existence probability
    
    # Set tracks in estimation layer
    estimation_layer.tracks = [high_conf_track, low_conf_track]
    
    print(f"Created {len(estimation_layer.tracks)} test tracks")
    print(f"Extraction threshold: {config.EXISTENCE_THRESHOLD_EXTRACTION}")
    
    for i, track in enumerate(estimation_layer.tracks):
        print(f"  Track {i}: existence={track.existence_probability:.4f}")
    
    # Test extraction
    extracted_state = estimation_layer._extract_state()
    
    print(f"Extracted State: {len(extracted_state)} tracks")
    
    for i, obj in enumerate(extracted_state):
        print(f"  Extracted Object {i}:")
        print(f"    Existence: {obj.get('existence_probability', 'N/A'):.4f}")
        print(f"    Position: {obj.get('mean', [0, 0, 0])[:3]}")

def main():
    """Run all debug functions."""
    print("Starting LMB Filter Debug...")
    
    # Run all debug functions
    debug_lmb_filter()
    debug_measurement_generation()
    debug_track_creation()
    debug_extraction_process()
    
    print("\n" + "="*80)
    print("DEBUG COMPLETE")
    print("="*80)
    print("Check the output above to understand why tracks aren't being detected.")
    print("Key things to look for:")
    print("1. Are measurements being generated?")
    print("2. Are tracks being created from measurements?")
    print("3. Are track existence probabilities increasing?")
    print("4. Are tracks passing the extraction threshold?")
    print("5. Are extracted tracks matching ground truth?")

if __name__ == "__main__":
    main() 