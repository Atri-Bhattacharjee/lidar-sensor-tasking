"""
Constellation Loader Utility

This module loads the actual constellation parameters from the .dia files
generated by the MASTER model, ensuring consistency across the codebase.
"""

import os
import numpy as np
from typing import Dict, List, Tuple
import re
import config


def load_constellation_parameters() -> Dict[str, Dict[str, float]]:
    """
    Load constellation parameters from .dia files in the output directory.
    
    Returns:
        Dictionary mapping satellite IDs (e.g., 'P1-S1') to orbital parameters
    """
    constellation_params = {}
    
    # Base directory for .dia files
    base_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))
    output_dir = os.path.join(base_dir, "output")
    
    # Pattern to match satellite files: P{plane}-S{satellite}_{type}.dia
    pattern = r'P(\d+)-S(\d+)_[cdr]\.dia'
    
    for filename in os.listdir(output_dir):
        if filename.endswith('.dia'):
            match = re.match(pattern, filename)
            if match:
                plane = int(match.group(1))
                satellite = int(match.group(2))
                satellite_id = f"P{plane}-S{satellite}"
                
                # Only process each satellite once (all three file types have same parameters)
                if satellite_id not in constellation_params:
                    filepath = os.path.join(output_dir, filename)
                    params = extract_orbital_parameters(filepath)
                    if params:
                        constellation_params[satellite_id] = params
    
    return constellation_params


def extract_orbital_parameters(filepath: str) -> Dict[str, float]:
    """
    Extract orbital parameters from a .dia file.
    
    Args:
        filepath: Path to the .dia file
        
    Returns:
        Dictionary containing orbital parameters
    """
    try:
        with open(filepath, 'r') as f:
            for line in f:
                if 'orbiting target (sphere) with parameters (ECI frame)' in line:
                    # Parse the line: "orbiting target (sphere) with parameters (ECI frame)   7228.000 km, 0.00100,  98.600 deg, 204.421 deg,  112.900 deg"
                    # Format: semi_major_axis (km), eccentricity, inclination (deg), RAAN (deg), mean_anomaly (deg)
                    parts = line.split(')')[-1].strip().split(',')
                    
                    if len(parts) >= 5:
                        semi_major_axis = float(parts[0].strip().split()[0]) * 1000  # Convert km to m
                        eccentricity = float(parts[1].strip())
                        inclination = float(parts[2].strip().split()[0])  # degrees
                        raan = float(parts[3].strip().split()[0])  # degrees
                        mean_anomaly = float(parts[4].strip().split()[0])  # degrees
                        
                        return {
                            'semi_major_axis': semi_major_axis,
                            'eccentricity': eccentricity,
                            'inclination': inclination,
                            'raan': raan,
                            'mean_anomaly': mean_anomaly
                        }
    except Exception as e:
        print(f"Warning: Could not extract parameters from {filepath}: {e}")
    
    return None


def get_constellation_positions(time_seconds: float = 0.0) -> np.ndarray:
    """
    Get constellation satellite positions based on the actual .dia file parameters.
    
    Args:
        time_seconds: Time since epoch in seconds (default: 0.0 for initial positions)
        
    Returns:
        Array of satellite positions [x, y, z] for each satellite
    """
    constellation_params = load_constellation_parameters()
    positions = []
    
    # Sort satellites by ID to ensure consistent ordering
    sorted_satellites = sorted(constellation_params.keys())
    
    for satellite_id in sorted_satellites:
        params = constellation_params[satellite_id]
        
        # Convert orbital elements to Cartesian coordinates at the specified time
        position = orbital_elements_to_cartesian_at_time(params, time_seconds)
        positions.append(position)
    
    return np.array(positions)


def orbital_elements_to_cartesian_at_time(orbital_elements: Dict[str, float], time_seconds: float) -> np.ndarray:
    """
    Convert orbital elements to Cartesian coordinates at a specific time.
    
    Args:
        orbital_elements: Dictionary containing orbital parameters
        time_seconds: Time since epoch in seconds
        
    Returns:
        Position vector [x, y, z] in meters
    """
    # Extract parameters
    a = orbital_elements['semi_major_axis']  # Semi-major axis in meters
    e = orbital_elements['eccentricity']     # Eccentricity
    i = np.radians(orbital_elements['inclination'])  # Inclination in radians
    raan = np.radians(orbital_elements['raan'])      # RAAN in radians
    M0 = np.radians(orbital_elements['mean_anomaly'])  # Initial mean anomaly in radians
    
    # Calculate mean motion
    mu = config.GRAVITATIONAL_CONSTANT
    n = np.sqrt(mu / (a**3))  # Mean motion (rad/s)
    
    # Propagate mean anomaly to the specified time
    M = M0 + n * time_seconds
    
    # For near-circular orbits (e ≈ 0.001), we can approximate:
    # - Argument of perigee = 0 (perigee at ascending node)
    # - True anomaly ≈ mean anomaly
    argp = 0.0  # Argument of perigee (assumed to be 0 for near-circular orbits)
    nu = M      # True anomaly ≈ mean anomaly for small eccentricity
    
    # Calculate radius
    r_mag = a * (1 - e**2) / (1 + e * np.cos(nu))
    
    # Calculate position in orbital plane
    x_orb = r_mag * np.cos(nu)
    y_orb = r_mag * np.sin(nu)
    z_orb = 0
    
    # Transform to inertial frame using rotation matrices
    cos_raan = np.cos(raan)
    sin_raan = np.sin(raan)
    cos_argp = np.cos(argp)
    sin_argp = np.sin(argp)
    cos_i = np.cos(i)
    sin_i = np.sin(i)
    
    # Position in inertial frame
    x = (cos_raan * cos_argp - sin_raan * sin_argp * cos_i) * x_orb + \
        (-cos_raan * sin_argp - sin_raan * cos_argp * cos_i) * y_orb
    y = (sin_raan * cos_argp + cos_raan * sin_argp * cos_i) * x_orb + \
        (-sin_raan * sin_argp + cos_raan * cos_argp * cos_i) * y_orb
    z = sin_argp * sin_i * x_orb + cos_argp * sin_i * y_orb
    
    return np.array([x, y, z])


def orbital_elements_to_cartesian(orbital_elements: Dict[str, float]) -> np.ndarray:
    """
    Convert orbital elements to Cartesian coordinates (initial position only).
    This is kept for backward compatibility.
    
    Args:
        orbital_elements: Dictionary containing orbital parameters
        
    Returns:
        Position vector [x, y, z] in meters
    """
    return orbital_elements_to_cartesian_at_time(orbital_elements, 0.0)


def get_constellation_summary() -> Dict:
    """
    Get a summary of the constellation configuration.
    
    Returns:
        Dictionary containing constellation summary
    """
    constellation_params = load_constellation_parameters()
    
    if not constellation_params:
        return {"error": "No constellation parameters found"}
    
    # Analyze the constellation
    satellites = list(constellation_params.keys())
    num_satellites = len(satellites)
    
    # Extract unique orbital planes
    planes = set()
    for sat_id in satellites:
        plane = sat_id.split('-')[0]
        planes.add(plane)
    
    num_planes = len(planes)
    sats_per_plane = num_satellites // num_planes
    
    # Get parameter ranges
    inclinations = [params['inclination'] for params in constellation_params.values()]
    altitudes = [(params['semi_major_axis'] - config.EARTH_RADIUS_M) / 1000 for params in constellation_params.values()]  # km
    mean_anomalies = [params['mean_anomaly'] for params in constellation_params.values()]
    
    # Calculate orbital period for one satellite (they're all similar)
    if constellation_params:
        sample_params = list(constellation_params.values())[0]
        a = sample_params['semi_major_axis']
        mu = config.GRAVITATIONAL_CONSTANT
        orbital_period = 2 * np.pi * np.sqrt(a**3 / mu)  # seconds
        orbital_period_minutes = orbital_period / 60
    else:
        orbital_period_minutes = 0
    
    summary = {
        "total_satellites": num_satellites,
        "num_planes": num_planes,
        "satellites_per_plane": sats_per_plane,
        "inclination_range": (min(inclinations), max(inclinations)),
        "altitude_range_km": (min(altitudes), max(altitudes)),
        "mean_anomaly_range": (min(mean_anomalies), max(mean_anomalies)),
        "orbital_period_minutes": orbital_period_minutes,
        "satellite_ids": sorted(satellites)
    }
    
    return summary 